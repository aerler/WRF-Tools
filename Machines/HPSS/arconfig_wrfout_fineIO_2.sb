#!/bin/bash
## queue/SLURM settings
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=40
# 72h is maximum for long queue, 1h for short
#SBATCH --time=72:00:00
# archive queue (long or short)
#SBATCH -p archivelong
# std and error output (job_name.job_id.out)
#SBATCH --output=%x.%j.out
# send email if abort (nbae)
#SBATCH --mail-user="$EMAIL"
#SBATCH --mail-type=END,FAIL
# job name
#SBATCH -J cycling_ar


#set -o pipefail # through error (in exit code) if pipe fails
trap "echo 'Job script not completed';exit 129" TERM INT

# if the $ARCHIVE environment variable does not exist anymore, we create it,
ARCHIVE=${ARCHIVE:-"${HOME/home/archive}"} # because we need it later

## definitions
# set $TAGS to determine, which file sets to archive
# operation to perform: LIST, VERIFY, REMOVE, BACKUP, RETRIEVE
MODE=${MODE:-'BACKUP'} # default operation: 'BACKUP'
RMSRC=${RMSRC:-'FALSE'} # set to 'RMSRC' to actually perform deletion
# N.B. if retrieving files, RMSRC means files on disk are overwritten/clobbered
VERIFY=${VERIFY:-'VERIFY'} # verify tarballs; can slow down operations significantly
# N.B.: do not edit these variable; instead pass them as environment variables
DOMAINS=${DOMAINS:-'1234'} # string with relevant domain indices
DATASET=${DATASET:-'FULL'} # default dataset: everything
# dataset options: FINAL, LOGS, DIAGS, ATM3D, SNOW, DEL3D, FULL
# N.B.: the datasets are defined in PROCESSDATASET below
ARINTERVAL='YEARLY' # default, which is updated by setupExperiment
INTERVAL=${INTERVAL:-"${ARINTERVAL}"} # default is set by ARINTERVAL 
PATTERN=${PATTERN:-'_wrf.tgz'} # $TAGS inference from certain files
PATREGX=${PATREGX:-''} # matching regex for $TAGS: roughly TAGS=$(ls *$PATTERN | grep -o $PATREGX)
TAGGLOB=${TAGGLOB:-''} # globbing extension for $TAGS (TAGSTR="${TAG}${TAGGLOB}")
# data folder
INIDIR=${INIDIR:-"${SLURM_SUBMIT_DIR}"}
DST=${DST:-"${ARCHIVE}/${INIDIR#/*/${USER}/}/"} # replicate directory tree
# replace things like '/scratch/g/group/user/' with $ARCHIVE
WRFOUT="${INIDIR}/wrfout/" # output folder
SRC=${SRC:-"${WRFOUT}"} # where the data is (on disk)

# check  against : some combinations can override archives!
# LIST, VERIFY, REMOVE, BACKUP, RETRIEVE
# first check MODE
case "${MODE}" in
  LIST | VERIFY | REMOVE | BACKUP | RETRIEVE )   MODEOK='FALSE';; # proceed with DATASET check
  * )  echo -e "\nERROR: Unknown Mode '${MODE}' - aborting!\n"; exit 1;; # unknown MODE: abort
esac # check MODE
# then check DATASET
case "${DATASET}" in
  FULL | ATM3D | SNOW | DIAGS )   # datasets that correspond to archive files   
    MODEOK='MODEOK';; # everything is OK
  DEL3D | LOGS | FINAL )   # only REMOVE/RETRIEVE options   
    if [[ "${MODE}" == 'BACKUP' ]]; then MODEOK='FALSE'; else MODEOK='MODEOK'; fi;; # everythin except backup
  * )   MODEOK='UNKNOWN';;
esac #  vs. 
# report error and exit, if necessary
if [[ "${MODEOK}" != 'MODEOK' ]]; then
  if [[ "${MODEOK}" == 'UNKNOWN' ]]; then
    echo -e "\nERROR: Unknown Dataset '${DATASET}' - aborting!\n"
  else
    echo -e "\nERROR: Mode '${MODE}' and Dataset '${DATASET}' incompatible - aborting!\n"
  fi # error message
  exit 1  
fi # print error output

# configure archiving interval presets
#if [[ -n "${TAGGLOB}" ]]; then
#  INTERVAL='CUSTOM' # use custom interval determined by the complement of $TAGGLOB
#  PATTERN=${PATTERN:-'_wrf.tgz'} # assuming the step name is the start date
if [[ "${INTERVAL}" == 'YEARLY' ]]; then
  PATREGX='^[0-9][0-9][0-9][0-9]'
  TAGGLOB='-[01][0-9]-[0123][0-9]' # match all months (01-12) and days (1-31)
elif [[ "${INTERVAL}" == 'MONTHLY' ]]; then
  PATREGX='^[0-9][0-9][0-9][0-9]-[01][0-9]'
  TAGGLOB='-[0123][0-9]' # match all days in a month
elif [[ "${INTERVAL}" == 'DAILY' ]] || [[ "${INTERVAL}" == 'NONE' ]]; then
  # N.B.: This option identifies output files by start date (day), without use of
  #       globbing expressions; it doesn't have to archive every day.
  PATREGX='.*' # just use everything... except $PATTERN
  TAGGLOB='' # actually no globbing necessary
fi # ${INTERVAL}

# check if we are using globbing expressions in filenames
if [[ -n "${TAGGLOB}" ]]; then GLOB='GLOB'; else GLOB='NO'; fi

## function to check the contents of an HTAR archive
function CHECKARCHIVE () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files that should be in the archive
  local LIST=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ) # column 7 are the file names, except last two lines
  # N.B.: can't capture exit code of htar because of $()
  local MISS=0 # missing file counter
  # evaluate globbing expression
  if [[ "${GLOB}" == 'GLOB' ]]; then
    FILES=$( ls -1 ${FILES} ); fi
  # loop over files in list and check presence in HTAR list
  for FILE in ${FILES}; do
    if [[ "${FILE}" != $( echo "${LIST}" | sed -n "/${FILE}/p" ) ]]; then
      if [[ ${MISS} == 0 ]]; then echo; fi # visually offset missing file list
      echo "WARNING: File ${FILE} missing in archive ${HTAR}"
      MISS=$(( ${MISS} + 1 ))
    fi
  done
  if [[ ${MISS} != 0 ]]; then echo; fi # visually offset missing file list
  # return number of missing files
  return ${MISS}
} # CHECKARCHIVE

## function to check if the contents of an HTAR archive are present on the source file system
function CHECKDISK () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local MODE="${2}" # report missing files or present files
  local LIST=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ) # column 7 are the file names, except last two lines
  # N.B.: can't capture exit code of htar because of $()
  local MISS=0 # missing file counter
  # check which files exist in source folder and report missing/present
  for FILE in ${LIST}; do # no quotes! white space delimited list!
    if [[ ! -e "${FILE}" ]] && [[ "${MODE}" == 'MISSING' ]]; then 
      echo "WARNING: File ${FILE} missing in source folder!"
      MISS=$(( ${MISS} + 1 ))
    elif [[ -e "${FILE}" ]] && [[ "${MODE}" == 'PRESENT' ]]; then 
      echo "WARNING: File ${FILE} present in source folder!"
      MISS=$(( ${MISS} + 1 ))
    fi # if -e $FILE
  done # for $LIST
  return ${MISS}
} # CHECKDISK

## function to list contents of HTAR archive
function LISTHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local ERR=0 # error code
  echo "${HTAR} ::: *" # print feedback
  # check if archive exists
  hsi -q ls "${HTAR}" &> /dev/null # quiet mode
  if [[ $? != 0 ]]; then
	echo "Warning: archive ${HTAR} does not exist (or HSI failed)."
	ERR=1
  else
    # list archive contents
	htar -tvf "${HTAR}" -Hcrc -Hverify=1
	ERR=$? # capture exit code
	CHECKDISK "${1}" 'MISSING'
  fi
  # return exit code
  return ${ERR}
}

## function to verify contents of HTAR archive
function VERIFYHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files that should be in the archive
  local QUIET="${3}" # suppress positive output (still print missing files!)
  local MISS=0 # error code
  # if globbing, just use archive table of contents
  if [[ "${GLOB}" == 'GLOB' ]]; then
    # get file list from table of contents (7th column, remove last two lines)
    FILES=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ); fi
  # print expected archive contents
  if [[ "${QUIET}" != 'QUIET' ]]; then
    echo "${HTAR}   :::   ${FILES}"; fi # print feedback
  # check if archive exists
  hsi -q ls "${HTAR}" &> /dev/null # quiet mode
  if [[ $? != 0 ]]; then
		echo "Warning: archive ${HTAR} does not exist (or HSI failed)."
		MISS=1
  else
    # verify archive contents
    if [[ "${VERIFY}" == 'VERIFY' ]]; then
      # evaluate globbing expression
      if [[ "${GLOB}" == 'GLOB' ]]; then
				htar -Kvf "${HTAR}" -Hcrc -Hverify=1 # verifying all files
				MISS=$?
      else
				htar -Kvf "${HTAR}" -Hcrc -Hverify=1 ${FILES}
				MISS=$?
      fi # $GLOB
    else
      # check contents without verification...
      echo "Warning: verification is switched off - checking contents instead."
      CHECKARCHIVE "${1}" "${2}" # check contents
      MISS=$? # number of missing files
    fi # $VERIFY
  fi
  # return exit code
  return ${MISS}
}

## function to remove source files of an HTAR archive
function REMOVEHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files that should be in the archive
  local LIST=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ) # column 7 are the file names, except last two lines
  local MISS=0 # missing file counter
  # check if files are present on disk
  # evaluate globbing expression (read list of existing files from disk)
  if [[ "${GLOB}" == 'GLOB' ]]; then FILES=$( ls -1 ${FILES} ); fi
  # print expected archive contents
  echo "${HTAR}   ---   ${FILES}" # print feedback
  # check if any of the given files still exist
  CNT=0; for F in ${FILES}; do
    if [[ -e "${F}" ]]; then CNT=$(( CNT + 1 )); fi; done;
  # begin removal process if any of the files are present
  if [[ -n "${CNT}" ]] && [[ ${CNT} == 0 ]]; then
	    echo '   >>> none of the files exist anymore - skipping this step!'
	    echo '   (use the VERIFY operation to verify integrity of the archive)'
  else
    if [[ "${VERIFY}" == 'VERIFY' ]]; then
      # verify archive contents
      VERIFYHTAR "${1}" "${2}" 'QUIET'
      MISS=$?
    else
      # check contents without verification...
      echo "Warning: verification is switched off - checking contents instead."
      CHECKARCHIVE "${1}" "${2}" # check contents
      MISS=$?
    fi # $VERIFY
    if [[ $MISS == 0 ]]; then
      # loop over files in list and check presence in HTAR list
      for FILE in ${FILES}; do
	      if [[ "${FILE}" == $( echo "${LIST}" | sed -n "/${FILE}/p" ) ]]; then
	        if [[ "${RMSRC}" == 'RMSRC' ]]; then # additional safety check
	          if [[ -e "${FILE}" ]]; then
	            echo "   >>> removing ${FILE}"
	            rm "${FILE}"
	          else echo "   ### ${FILE} does not exist"; fi # -e $FILE
	        else
	          echo "   >>> would remove ${FILE}, if RMSRC='RMSRC' was set..."
	        fi # RMSRC
	      else
	        if [[ ${MISS} == 0 ]]; then echo; fi # visually offset missing file list
	        echo "WARNING: File ${FILE} missing in archive ${HTAR}"
	        echo "   >>> not deleting ${FILE}"
	        MISS=$(( ${MISS} + 1 ))
	      fi # $FILE in HTAR
      done # loop over $FILES
    else
      echo
      echo "   >>>   Cannot verify integrity of archive ${HTAR} - aborting!   <<<   "
      echo
      MISS=1
    fi # if HTAR OK
  fi # if $FILES on disk
  # return number of missing files
  return ${MISS}
}

## function to create a new HTAR archive
function BACKUPHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} #
  # evaluate globbing expression
  if [[ "${GLOB}" == 'GLOB' ]]; then
    FILES=$( ls -1 ${FILES} ); fi # display output in columns (i.e. long lines)
  # check if archive already exists
  echo "${FILES}   >>>   ${HTAR}" # print feedback
  hsi -q ls "${HTAR}" &> /dev/null # quiet mode
  if [[ $? == 0 ]]; then
    echo "Warning: archive ${HTAR} already exists - checking contents."
    CHECKARCHIVE "${1}" "${2}" # check contents
    if [[ $? == 0 ]]; then
      echo "   Archive OK, skipping backup..."
      return 0
    else
      echo 'Archive contents are different: need to check, if all files are present on source file system.'
      CHECKDISK "${1}" 'MISSING'
      if [[ $? == 0 ]]; then 
				echo "   WARNING: All archive contents are present - removing old archive and creating new."
				hsi -q rm "${HTAR}"
      else
				echo "   WARNING: Some archive contents are missing on source file system - cannot replace archive."
				echo "   (Retrieve current contents first, before recreating the new archive.)" 
				exit 1 # this is an error
      fi # CHECKDISK
    fi # CHECKARCHIVE
  fi # archive already exists
  # create archive, store output message and remove redundant error messages
  TMPFOLDER="/dev/shm/${USER}_ar_tmp_${SLURM_JOBID}"
  mkdir -p ${TMPFOLDER}
  TMPFILE="/dev/shm/${USER}_ar_tmp_${SLURM_JOBID}/htarout.out"
  htar -cpf "${HTAR}" -Humask=0137 -Hcrc -Hverify=1 ${FILES} &> ${TMPFILE}
  sed -i '/ERROR: \[Uint32_tToOctal\]Octal field \[thb_[ug]id\] overflow \- width=8 value=/d' ${TMPFILE}
  # NOTE: As the errors of the type "ERROR: [Uint32_tToOctal]Octal field [thb_[ug]id] overflow - width=8 value=..."
  #   are not actual errors, we do remove these from the output message, to not confuse them with actual errors.
  HTAROUT=$(cat ${TMPFILE})  
  rm -rf ${TMPFOLDER}   
  # Check the output message
  if [[ -n $( echo ${HTAROUT} | sed -n "/HTAR SUCCESSFUL/p" ) ]]; then
      echo ${HTAROUT}
  else
      echo 'HTAR failed!'
      exit 1
  fi  
  ERR=$? # capture exit code
  # verify contents/completion
  if [[ $ERR != 0 ]]; then
	# report error
	echo "   ERROR: HTAR did not complete successfully; exit code ${ERR}"
	MISS=$ERR # use as exit code below
  elif [[ "${VERIFY}" == 'VERIFY' ]]; then
    # verify archive contents
    echo "Verifying contents (not sure if this is necessary, but doesn't hurt.)"
    VERIFYHTAR "${1}" "${2}" 'QUIET'
    MISS=$? # capture exit code: number of missing files
  else
    # verify without verification...
    echo "Warning: verification is switched off - checking contents instead."
    CHECKARCHIVE "${1}" "${2}" # check contents
    MISS=$? # capture exit code: number of missing files
  fi # $VERIFY
  # return results of verification
  return $MISS
}

## function to create a new HTAR archive
function RETRIEVEHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files to extract
  local MISS=0 # exit code
  # if globbing, just use archive table of contents
  if [[ "${GLOB}" == 'GLOB' ]]; then
    # get file list from table of contents (7th column, remove last two lines)
    FILELIST=$( htar -tf ${HTAR} | awk '{print $7}' | head -n -2 )
    # apply globbing expression to file list using fake files on RAM-disk
    TMP="/dev/shm/${USER}_ar_tmp_${SLURM_JOBID}/" # temporary working folder on RAM-disk
    mkdir -p "${TMP}"; cd "${TMP}" # create temporary folder and go into it
    for F in $FILELIST; do touch "$F"; done # create dummy files from list
    FILES=$( ls -1 ${FILES} ) # get formatted file list (entries as columns)
    cd - 1>/dev/null; rm -r "${TMP}" # return to previous folder and clean up
  fi # $GLOB
  echo "${HTAR}   >>>   ${FILES}" # print feedback
  # check if archive exists and verify integrity (VERIFYHTAR checks existence)
  if [[ "${VERIFY}" == 'VERIFY' ]]; then
    # verify archive contents
    echo "Verifying contents."
    VERIFYHTAR "${1}" "${2}" 'QUIET'
    MISS=$?
  else
    # verify without verification...
    echo "Warning: verification is switched off - checking contents instead."
    CHECKARCHIVE "${1}" "${2}" # check contents
    MISS=$?
  fi # $VERIFY
  if [[ $MISS != 0 ]]; then
	  echo "Warning: verification of archive ${HTAR} failed - aborting!"
  else # if verified
    echo "Archive ${HTAR} exists - contents OK."
    # evaluate globbing expression
    echo
    if [[ "${RMSRC}" == 'RMSRC' ]]; then
      # check which files already exist, and report them (will get clobbered)
      CHECKDISK "${1}" 'PRESENT'
      if [[ $? != 0 ]]; then echo "WARNING: Clobbering existing files!"; fi      
      # extract archive
      htar -xpmf "${HTAR}" -Hcrc -Hverify=1 ${FILES} # all files: globbing and clobbering
	    MISS=$?
    else
      # check which files already exist, and skip them (don't clobber)
      NFS=''; for F in ${FILES}; do # no quotes! white space delimited list!
		  	if [[ ! -e "${F}" ]]; then NFS="${NFS} ${F}"; fi; done
      if [[ -n "${NFS}" ]]; then
				echo "Skipping existing files; retrieving ${NFS}"	
				htar -xpmf "${HTAR}" -Hcrc -Hverify=1 ${NFS} # extract archive
				MISS=$?
      else
  		  echo 'Files already exist in destination folder; run with $RMSRC=RMSRC to overwrite.'
      fi # $NFS
      echo
	  fi # $CLOBBER    
    
  fi # if verified
  # verify contents and return result
  return ${MISS}
}

## function to back up one output dataset
# N.B.: this function is specific to the WRF output configuration; it
#       has to be redefined, to accommodate different output configurations
function PROCESSDATASET () {
  local DATE="${1}" # the current $TAG, in this context (WRF) the date...
  local ERR=0 # error counter
  ## define datasets
  DATENAME="${DATE}" # used in archive file names etc.  
  # use globbing expression if asked
  if [[ "${GLOB}" == 'GLOB' ]]; 
    then DATESTR="${DATE}${TAGGLOB}"
    else DATESTR="${DATE}"  # used in output data file names
  fi # GLOB
  unset FINAL STATIC LOGS DIAGS_D1 DIAGS_D2 DIAGS_D3 DIAGS_D4 ATM3D_D1 ATM3D_D2 ATM3D_D3 ATM3D_D4 SNOW_D1 SNOW_D2 SNOW_D3 SNOW_D4
  if [[ "${DATE}" == 'FINAL' ]] &&  [[ "${MODE}" == 'BACKUP' ]]; then # all domains, only last time step
    local FINAL="static.tgz *_pyWPS.tgz *_real.tgz *_wrf.tgz *_logs.tgz" # put configuration files, all logs, and restart files into one archive
    for D in $( echo "${DOMAINS}" | fold --width=1 ); do
      LSTRST=$( ls wrfrst_d0${D}_* | tail -n 1 ) # last restart for every domain
      FINAL="${FINAL} wrfconst_d0${D}.nc ${LSTRST}"
    done # $DOMAINS
  elif [[ "${DATASET}" == 'FINAL' ]] &&  [[ "${MODE}" == 'RETRIEVE' ]]; then # all domains, only specified date; only for retrieval
    local FINAL="static.tgz ${DATESTR}_pyWPS.tgz ${DATESTR}_real.tgz ${DATESTR}_wrf.tgz" # configuration files and restart files in one archive
    # N.B.: Logs can not be retrieved with this method, because they do not follow the ${DATESTR}_logs.tgz format (use DATASET=LOGS instead).
    for D in $( echo "${DOMAINS}" | fold --width=1 ); do
      FINAL="${FINAL} wrfconst_d0${D}.nc wrfrst_d0${D}_${DATESTR}"
    done # $DOMAINS
  else
    ## select datasets and logs
    # logs and static data
    if [[ "${DATASET}" == 'LOGS' ]] || [[ "${DATASET}" == 'DIAGS' ]] || [[ "${DATASET}" == 'FULL' ]]; then
      local STATIC="static.tgz" # only on cold start, otherwise skip
      for D in $( echo "${DOMAINS}" | fold --width=1 ); do
	      STATIC="${STATIC} wrfconst_d0${D}.nc"
      done # $DOMAINS
      local LOGS="${DATE}*_pyWPS.tgz ${DATE}*_real.tgz ${DATE}*_wrf.tgz ${DATENAME}_logs.tgz"
      # N.B.: log files have the step name and not the date in their file name, hence the irregularity
    # diagnostics (one file per domain)
    fi; if [[ "${DATASET}" == 'DIAGS' ]] || [[ "${DATASET}" == 'FULL' ]]; then      
      DIAGS_D1="wrffdda_d01_${DATESTR}_??[:_]??[:_]??* wrfxtrm_d01_${DATESTR}_??[:_]??[:_]??* wrfsrfc_d01_${DATESTR}_??[:_]??[:_]??* wrfplev3d_d01_${DATESTR}_??[:_]??[:_]??* wrflsm_d01_${DATESTR}_??[:_]??[:_]??* wrfrad_d01_${DATESTR}_??[:_]??[:_]??* wrfhydro_d01_${DATESTR}_??[:_]??[:_]??*"
      DIAGS_D2="wrfxtrm_d02_${DATESTR}_??[:_]??[:_]??* wrfsrfc_d02_${DATESTR}_??[:_]??[:_]??* wrfplev3d_d02_${DATESTR}_??[:_]??[:_]??* wrflsm_d02_${DATESTR}_??[:_]??[:_]??* wrfrad_d02_${DATESTR}_??[:_]??[:_]??* wrfhydro_d02_${DATESTR}_??[:_]??[:_]??*"  
      DIAGS_D3="wrfxtrm_d03_${DATESTR}_??[:_]??[:_]??* wrfsrfc_d03_${DATESTR}_??[:_]??[:_]??* wrfplev3d_d03_${DATESTR}_??[:_]??[:_]??* wrflsm_d03_${DATESTR}_??[:_]??[:_]??* wrfrad_d03_${DATESTR}_??[:_]??[:_]??* wrfhydro_d03_${DATESTR}_??[:_]??[:_]??*"
      DIAGS_D4="wrfxtrm_d04_${DATESTR}_??[:_]??[:_]??* wrfsrfc_d04_${DATESTR}_??[:_]??[:_]??* wrfplev3d_d04_${DATESTR}_??[:_]??[:_]??* wrflsm_d04_${DATESTR}_??[:_]??[:_]??* wrfrad_d04_${DATESTR}_??[:_]??[:_]??* wrfhydro_d04_${DATESTR}_??[:_]??[:_]??*"
    ## select domain-wise datasets
    # large 3D fields (one file per domain)
    fi; if [[ "${DATASET}" == 'ATM3D' ]] || [[ "${DATASET}" == 'DEL3D' ]] || [[ "${DATASET}" == 'FULL' ]]; then
      local ATM3D_D1="wrfdrydyn3d_d01_${DATESTR}_??[:_]??[:_]??* wrfmoist3d_d01_${DATESTR}_??[:_]??[:_]??* wrfrst_d01_${DATESTR}_??[:_]??[:_]??*"
      local ATM3D_D2="wrfdrydyn3d_d02_${DATESTR}_??[:_]??[:_]??* wrfmoist3d_d02_${DATESTR}_??[:_]??[:_]??* wrfrst_d02_${DATESTR}_??[:_]??[:_]??*" 
      local ATM3D_D3="wrfdrydyn3d_d03_${DATESTR}_??[:_]??[:_]??* wrfmoist3d_d03_${DATESTR}_??[:_]??[:_]??* wrfrst_d03_${DATESTR}_??[:_]??[:_]??*"
      local ATM3D_D4="wrfdrydyn3d_d04_${DATESTR}_??[:_]??[:_]??* wrfmoist3d_d04_${DATESTR}_??[:_]??[:_]??* wrfrst_d04_${DATESTR}_??[:_]??[:_]??*"
    # Snow files (one file per domain)
    fi; if [[ "${DATASET}" == 'SNOW' ]] || [[ "${DATASET}" == 'DEL3D' ]] || [[ "${DATASET}" == 'FULL' ]]; then 
      local SNOW_D1="wrfsnow_d01_${DATESTR}_??[:_]??[:_]??*"
      local SNOW_D2="wrfsnow_d02_${DATESTR}_??[:_]??[:_]??*"
      local SNOW_D3="wrfsnow_d03_${DATESTR}_??[:_]??[:_]??*"
      local SNOW_D4="wrfsnow_d04_${DATESTR}_??[:_]??[:_]??*"
    fi 
    # Check if the contents of the variables exist    
    export IFS=$'\n '
    local FINAL_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrffinal.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${FINAL}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        FINAL_CHECKED="${FINAL_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${FINAL_CHECKED} ]]; then
      FINAL=${FINAL_CHECKED}    
    else
      unset FINAL
      echo 'FINAL assigned files did not exist. FINAL was unset.'
    fi   
    local STATIC_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfstatic.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${STATIC}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        STATIC_CHECKED="${STATIC_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${STATIC_CHECKED} ]]; then
      STATIC=${STATIC_CHECKED}    
    else
      unset STATIC
      echo 'STATIC assigned files did not exist. STATIC was unset.'
    fi
    local LOGS_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfdiags_d01_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${LOGS}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        LOGS_CHECKED="${LOGS_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${LOGS_CHECKED} ]]; then
      LOGS=${LOGS_CHECKED}    
    else
      unset LOGS
      echo 'LOGS assigned files did not exist. LOGS was unset.'
    fi
    local DIAGS_D1_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfdiags_d01_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${DIAGS_D1}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        DIAGS_D1_CHECKED="${DIAGS_D1_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${DIAGS_D1_CHECKED} ]]; then
      DIAGS_D1=${DIAGS_D1_CHECKED}    
    else
      unset DIAGS_D1
      echo 'DIAGS_D1 assigned files did not exist. DIAGS_D1 was unset.'
    fi
    local DIAGS_D2_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfdiags_d02_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${DIAGS_D2}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        DIAGS_D2_CHECKED="${DIAGS_D2_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${DIAGS_D2_CHECKED} ]]; then
      DIAGS_D2=${DIAGS_D2_CHECKED}    
    else
      unset DIAGS_D2
      echo 'DIAGS_D2 assigned files did not exist. DIAGS_D2 was unset.'
    fi
    local DIAGS_D3_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfdiags_d03_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${DIAGS_D3}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        DIAGS_D3_CHECKED="${DIAGS_D3_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${DIAGS_D3_CHECKED} ]]; then
      DIAGS_D3=${DIAGS_D3_CHECKED}    
    else
      unset DIAGS_D3
      echo 'DIAGS_D3 assigned files did not exist. DIAGS_D3 was unset.'
    fi
    local DIAGS_D4_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfdiags_d04_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${DIAGS_D4}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        DIAGS_D4_CHECKED="${DIAGS_D4_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${DIAGS_D4_CHECKED} ]]; then
      DIAGS_D4=${DIAGS_D4_CHECKED}    
    else
      unset DIAGS_D4
      echo 'DIAGS_D4 assigned files did not exist. DIAGS_D4 was unset.'
    fi    
    local ATM3D_D1_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfatm_d01_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${ATM3D_D1}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        ATM3D_D1_CHECKED="${ATM3D_D1_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${ATM3D_D1_CHECKED} ]]; then
      ATM3D_D1=${ATM3D_D1_CHECKED}    
    else
      unset ATM3D_D1
      echo 'ATM3D_D1 assigned files did not exist. ATM3D_D1 was unset.'
    fi
    local ATM3D_D2_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfatm_d02_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${ATM3D_D2}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        ATM3D_D2_CHECKED="${ATM3D_D2_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${ATM3D_D2_CHECKED} ]]; then
      ATM3D_D2=${ATM3D_D2_CHECKED}    
    else
      unset ATM3D_D2
      echo 'ATM3D_D2 assigned files did not exist. ATM3D_D2 was unset.'
    fi  
    local ATM3D_D3_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfatm_d03_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${ATM3D_D3}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        ATM3D_D3_CHECKED="${ATM3D_D3_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${ATM3D_D3_CHECKED} ]]; then
      ATM3D_D3=${ATM3D_D3_CHECKED}    
    else
      unset ATM3D_D3
      echo 'ATM3D_D3 assigned files did not exist. ATM3D_D3 was unset.'
    fi 
    local ATM3D_D4_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfatm_d04_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${ATM3D_D4}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        ATM3D_D4_CHECKED="${ATM3D_D4_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${ATM3D_D4_CHECKED} ]]; then
      ATM3D_D4=${ATM3D_D4_CHECKED}    
    else
      unset ATM3D_D4
      echo 'ATM3D_D4 assigned files did not exist. ATM3D_D4 was unset.'
    fi 
    local SNOW_D1_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfsnow_d01_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${SNOW_D1}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        SNOW_D1_CHECKED="${SNOW_D1_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${SNOW_D1_CHECKED} ]]; then
      SNOW_D1=${SNOW_D1_CHECKED}    
    else
      unset SNOW_D1
      echo 'SNOW_D1 assigned files did not exist. SNOW_D1 was unset.'
    fi 
    local SNOW_D2_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfsnow_d02_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${SNOW_D2}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        SNOW_D2_CHECKED="${SNOW_D2_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${SNOW_D2_CHECKED} ]]; then
      SNOW_D2=${SNOW_D2_CHECKED}    
    else
      unset SNOW_D2
      echo 'SNOW_D2 assigned files did not exist. SNOW_D2 was unset.'
    fi
    local SNOW_D3_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfsnow_d03_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${SNOW_D3}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        SNOW_D3_CHECKED="${SNOW_D3_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${SNOW_D3_CHECKED} ]]; then
      SNOW_D3=${SNOW_D3_CHECKED}    
    else
      unset SNOW_D3
      echo 'SNOW_D3 assigned files did not exist. SNOW_D3 was unset.'
    fi
    local SNOW_D4_CHECKED=""
    if [[ ${MODE} == 'RETRIEVE' ]]; then    
      local TAR_FILES=$( htar -tf ${DST}"/wrfsnow_d04_${DATENAME}.tar" 2>/dev/null | awk '{print $7}' | head -n -2 )
    fi     
    for word in ${SNOW_D4}; do
      if [[ ${MODE} == 'BACKUP' ]] || [[ ${MODE} == 'REMOVE' ]]; then
        local EXIST=$( ls ${word} 2>/dev/null )
      elif [[ ${MODE} == 'RETRIEVE' ]]; then
        unset EXIST
        for word_tf in ${TAR_FILES}; do
          if [[ ${word_tf} == ${word} ]]; then
            EXIST="EXIST" 
          fi
        done
      fi  
      if [[ -n ${EXIST} ]]; then
        SNOW_D4_CHECKED="${SNOW_D4_CHECKED} ${word}"
      fi  
    done  
    if [[ -n ${SNOW_D4_CHECKED} ]]; then
      SNOW_D4=${SNOW_D4_CHECKED}    
    else
      unset SNOW_D4
      echo 'SNOW_D4 assigned files did not exist. SNOW_D4 was unset.'
    fi    
    # return error if dataset not found
    if [[ -z "${FINAL}" ]] && [[ -z "${STATIC}" ]] && [[ -z "${LOGS}" ]] && [[ -z "${DIAGS_D1}" ]] && [[ -z "${DIAGS_D2}" ]] && [[ -z "${DIAGS_D3}" ]] && [[ -z "${DIAGS_D4}" ]] && [[ -z "${ATM3D_D1}" ]] && [[ -z "${ATM3D_D2}" ]] && [[ -z "${ATM3D_D3}" ]] && [[ -z "${ATM3D_D4}" ]] && [[ -z "${SNOW_D1}" ]] && [[ -z "${SNOW_D2}" ]] && [[ -z "${SNOW_D3}" ]] && [[ -z "${SNOW_D4}" ]]
      then
	      echo
	      if [[ "${DATASET}" == 'FINAL' ]] || [[ "${DATASET}" == 'LOGS' ]] || [[ "${DATASET}" == 'DIAGS' ]] || [[ "${DATASET}" == 'ATM3D' ]] || [[ "${DATASET}" == 'SNOW' ]] || [[ "${DATASET}" == 'DEL3D' ]] || [[ "${DATASET}" == 'FULL' ]]
					then # known dataset but other problem
					  echo "   >>>   WARNING: dataset ${DATASET} can not be used in the desired configuration! (aborting)   <<<   "
					else # unknown dataset
					  echo "   >>>   WARNING: dataset ${DATASET} not found! (aborting)   <<<   "
	      fi # DATASET
	      echo
	      return 1
    fi # DIAGS etc.
  fi # if TAG=FINAL
  # determine if this is a cold start or a restart (check for restart files)
  ls "${SRC}"/wrfrst_d??_"${DATESTR}"_??[:_]??[:_]??* >& /dev/null # this only works with globbing expressions, if they are not quoted
  if [[ $? == 0  ]] && [[ "${GLOB}" != 'GLOB' ]]; then
      unset STATIC; fi # skip this step, if no globbing is used
  # cold start: backup data tables, constants, and geogrid files
  # N.B.: restart files have been added to regular MISC3D
  echo
  # operation feedback
  echo "   ***   ${MODE} ${DATENAME}   ***   "
  # delete source or not?
  if [[ ${RMSRC} == 'RMSRC' ]]
    then if [[ ${MODE} == 'RETRIEVE' ]]
	then echo "  (Overwriting source files!) "
	else echo " ++  Removing source files!  ++ "
      fi # $MODE
    else echo " (leaving source files untouched)   "
  fi # $RMSRC
  echo
  ## process file lists (skip empty ones)
  if [[ -n "${FINAL}" ]]; then
    # only executed at the end of an experiment
    echo '  Static data, logs, and WRF restart files (all domains):'
    "${MODE}HTAR" "wrffinal.tar" "${FINAL}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${STATIC}" ]]; then
    # only execute this for the first step/date (cold start)
    echo '  Static data, WRF constants, and geogrid files (all domains):'
    "${MODE}HTAR" "wrfstatic.tar" "${STATIC}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ "${DOMAINS}" == *1* ]]; then 
    if [[ -n "${DIAGS_D1}" ]] || [[ -n "${LOGS}" ]]; then
      echo
      echo 'Diagnostics (1st domain) and logs:' # short description of archive
      "${MODE}HTAR" "wrfdiags_d01_${DATENAME}.tar" "${DIAGS_D1} ${LOGS}"
      ERR=$(( ${ERR} + $? )) # returns the number of missing files as exit code
    fi
  fi; if [[ -n "${DIAGS_D2}" ]] && [[ "${DOMAINS}" == *2* ]]; then
    echo
    echo 'Diagnostics (2nd domain):' 
    "${MODE}HTAR" "wrfdiags_d02_${DATENAME}.tar" "${DIAGS_D2}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DIAGS_D3}" ]] && [[ "${DOMAINS}" == *3* ]]; then
    echo
    echo 'Diagnostics (3rd domain):' 
    "${MODE}HTAR" "wrfdiags_d03_${DATENAME}.tar" "${DIAGS_D3}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DIAGS_D4}" ]] && [[ "${DOMAINS}" == *4* ]]; then
    echo
    echo 'Diagnostics (4th domain):' 
    "${MODE}HTAR" "wrfdiags_d04_${DATENAME}.tar" "${DIAGS_D4}"
    ERR=$(( ${ERR} + $? ))  
  fi; if [[ -n "${ATM3D_D1}" ]] && [[ "${DOMAINS}" == *1* ]]; then
    echo
    echo '3D atmospheric fields and restart files (1st domain):'
    "${MODE}HTAR" "wrfatm_d01_${DATENAME}.tar" "${ATM3D_D1}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${ATM3D_D2}" ]] && [[ "${DOMAINS}" == *2* ]]; then
    echo
    echo '3D atmospheric fields and restart files (2nd domain):'
    "${MODE}HTAR" "wrfatm_d02_${DATENAME}.tar" "${ATM3D_D2}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${ATM3D_D3}" ]] && [[ "${DOMAINS}" == *3* ]]; then
    echo
    echo '3D atmospheric fields and restart files (3rd domain):'
    "${MODE}HTAR" "wrfatm_d03_${DATENAME}.tar" "${ATM3D_D3}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${ATM3D_D4}" ]] && [[ "${DOMAINS}" == *4* ]]; then
    echo
    echo '3D atmospheric fields and restart files (4th domain):'
    "${MODE}HTAR" "wrfatm_d04_${DATENAME}.tar" "${ATM3D_D4}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${SNOW_D1}" ]] && [[ "${DOMAINS}" == *1* ]]; then
    echo
    echo 'Snow (1st domain):'
    "${MODE}HTAR" "wrfsnow_d01_${DATENAME}.tar" "${SNOW_D1}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${SNOW_D2}" ]] && [[ "${DOMAINS}" == *2* ]]; then
    echo
    echo 'Snow (2nd domain):'
    "${MODE}HTAR" "wrfsnow_d02_${DATENAME}.tar" "${SNOW_D2}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${SNOW_D3}" ]] && [[ "${DOMAINS}" == *3* ]]; then
    echo
    echo 'Snow (3rd domain):'
    "${MODE}HTAR" "wrfsnow_d03_${DATENAME}.tar" "${SNOW_D3}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${SNOW_D4}" ]] && [[ "${DOMAINS}" == *4* ]]; then
    echo
    echo 'Snow (4th domain):'
    "${MODE}HTAR" "wrfsnow_d04_${DATENAME}.tar" "${SNOW_D4}"
    ERR=$(( ${ERR} + $? ))
  fi
  # check for errors
  if [[ ${ERR} != 0 ]]; then
    echo "   >>>   WARNING: there were ${ERR} errors!   <<<   "
    return 1
  else
    echo "${MODE} ${DATENAME} OK!"
    return 0
  fi
}

## execution

# set up directories
hsi mkdir -p "${DST}"
cd "${SRC}"

# feedback
echo
echo
echo '   Settings'
echo "Operation to perform:       MODE = ${MODE}"
echo "Delete source files?       RMSRC = ${RMSRC}"
echo "Verify archive integrity? VERIFY = ${VERIFY}"
echo "Use globbing expressions:   GLOB = ${GLOB}"
echo '   Dataset'
echo "File set to work on:     DATASET = ${DATASET}"
echo "Domains to include:      DOMAINS = ${DOMAINS}"
echo "Archiving interval:     INTERVAL = ${INTERVAL}"
echo '   Data Folders'
echo 'Archive folder:'
echo "  DST = ${DST}"
echo 'Source (disk) folder:'
echo "  SRC = ${SRC}"
echo
echo

# if no TAGS are given, use file pattern to guess
if [[ -z "${TAGS}" ]] && [[ -n "${PATTERN}" ]]; then
  echo "Inferring TAGS from pattern: PATTERN=${PATTERN}"
  LST= # detect duplicates
  for T in $( ls *${PATTERN} ); do
    TMP=$( echo "${T%${PATTERN}}" | grep -o "${PATREGX}" )
    # only add one occurence, no duplcates
    if [[ "$TMP" != "$LST" ]]; then
      TAGS="${TAGS} ${TMP}" 
      LST="${TMP}"
    fi # $TMP != $LST
  done # extract $TAG from filename
  echo "TAGS=${TAGS}"
else
  echo "TAGS provided by caller:"
  echo "TAGS=${TAGS}"
fi # if no $TAGS
echo
echo

# set counter
ERRORS=0
OPERATIONS=0
# cycle over monthly output datasets
for TAG in ${TAGS} # use WRF log-files as indicator
do
  time -p PROCESSDATASET ${TAG}
  if [ $? == 0 ]; then OPERATIONS=$(( ${OPERATIONS} + 1 ))
  else ERRORS=$(( ${ERRORS} + 1 )); fi
  echo
  echo '   ==========================================================================   '
  echo
done
hsi -q ls "${DST}"

trap - TERM INT

echo
if [ ${ERRORS} == 0 ]; then
  echo "   <<<   ALL ${OPERATIONS} OPERATIONS OK   >>>   "
  echo
  exit 0
else
  echo "   >>>   WARNING: ${ERRORS} OPERATIONS FAILED OR INCOMPLETE!   <<<   "
  echo "   >>>                 ${OPERATIONS} OPERATIONS OK             <<<   "
  echo
  # /scinet/gpc/bin/exit2msg ${ERRORS} # translate exit codes to human-readable messages
  exit ${ERRORS}
fi
